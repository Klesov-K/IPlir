/*
 * test.h
 *
 *  Created on: Jan 30, 2020
 *      Author: V.A.Kiryukhin
 */

#ifndef TEST_H_
#define TEST_H_

#include "cipher_base.h"
#include "magma.h"
#include "kuznyechik.h"
#include "cipher_modes.h"
#include "message.h"

//template<typename var, typename size>
//#define vector(var, size) vector<uint8_t> v_...var(size) \
//					uint8_t* var = v_...var.data()\

bool check(const uint8_t *a, const uint8_t *b, const size_t bytesize)
{
	if (memcmp(a, b, bytesize) == 0)
	{
		cout << "OK" << endl;
		return true;
	}
	else
	{
		cout << "Fail!" << endl;
		return false;
	}
}

bool check(const vector<uint8_t> &a, const vector<uint8_t> &b)
{
	return check(a.data(), b.data(), min(a.size(), b.size()));
}

void test_magma()
{
	BlockCipherPtr magma_ptr = buildTestMagma();
	const size_t block_byte_size = magma_ptr->getBlockByteSize();

	//uint8_t in [block_byte_size] = { 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 };
	//uint8_t out[block_byte_size] = { 0x00 };
	//uint8_t dec[block_byte_size] = { 0x00 };
	//uint8_t control[block_byte_size] = { 0x4e, 0xe9, 0x01, 0xe5, 0xc2, 0xd8, 0xca, 0x3d};

	vector<uint8_t> v_in{ 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 };
	uint8_t* in = v_in.data();

	vector<uint8_t> v_out(block_byte_size);
	uint8_t* out =	v_out.data();

	vector<uint8_t> v_dec(block_byte_size);
	uint8_t* dec =	v_dec.data();

	vector<uint8_t> v_control{ 0x4e, 0xe9, 0x01, 0xe5, 0xc2, 0xd8, 0xca, 0x3d };
	uint8_t* control =	v_control.data();


	magma_ptr->encrypt(in, out);

	magma_ptr->decrypt(out, dec);

	cout << to_hex(in , block_byte_size) << endl;
	cout << to_hex(out, block_byte_size) << endl;
	cout << to_hex(dec, block_byte_size) << endl;

	check(out, control, block_byte_size);
}

void test_gost89()
{
	GOST89Ptr gost89 = buildTestGOST89();

	//uint8_t keyFF00[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	//					 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,};

	const size_t block_byte_size = gost89->getBlockByteSize();


	uint8_t in[] = {0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09,0x08};
	//uint8_t out[block_byte_size] = { 0x00 };
	//uint8_t dec[block_byte_size] = { 0x00 };
	vector<uint8_t> v_out(block_byte_size);
	uint8_t* out = v_out.data();

	vector<uint8_t> v_dec(block_byte_size);
	uint8_t* dec = v_dec.data();

	uint8_t control[] = { 0x4b, 0x8c, 0x4c, 0x98, 0x15, 0xf2, 0x4a, 0xea, 0x1e, 0xc3, 0x57, 0x09, 0xb3, 0xbc, 0x2e, 0xd1};

	gost89->encrypt(in, out);
	gost89->decrypt(out, dec);

	cout << to_hex(in , block_byte_size) << endl;
	cout << to_hex(out, block_byte_size) << endl;
	cout << to_hex(dec, block_byte_size) << endl;

	check(out, control, block_byte_size);

	uint8_t to1[] = { 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCC, 0xCC, 0xCC, 0xCC,};

	//gost89->initKey(keyFF00);

	uint8_t mac[4] = {0x00};

	gost89->imit(to1,sizeof(to1),mac);
	//cout << to_hex(to1, sizeof(to1)) << endl;

	//ECB::encrypt(gost89, to1, to1, 16);

	//cout << to_hex(to1, sizeof(to1)) << endl;
	cout << to_hex(mac, sizeof(mac)) << endl;

	uint8_t control_mac[4] = {0x2c, 0x27, 0xc9, 0x5a};

	check(control_mac, mac,  sizeof(mac));
}

void test_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();

	uint8_t in [16] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88 };
	uint8_t out[16] = { 0x00 };
	uint8_t dec[16] = { 0x00 };
	uint8_t control[16] = { 0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42, 0xb9, 0xd4, 0xed, 0xcd };

	const size_t block_byte_size = kuzn_ptr->getBlockByteSize();

	kuzn_ptr->encrypt(in, out);
	kuzn_ptr->decrypt(out, dec);

	cout << to_hex(in , block_byte_size) << endl;
	cout << to_hex(out, block_byte_size) << endl;
	cout << to_hex(dec, block_byte_size) << endl;

	check(out, control, block_byte_size);
}


void test_ecb_magma()
{
	BlockCipherPtr magma_ptr = buildTestMagma();
	Message msg;

	msg.text_ = {0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
	msg.plaintext_size_ = msg.text_.size();

	auto backup_msg = msg;

	cout << to_hex(msg.text_) << endl;
	ECB::encrypt(magma_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;
	ECB::decrypt(magma_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);
}

void test_ctr_magma()
{
	BlockCipherPtr magma_ptr = buildTestMagma();
	Message msg;
	msg.text_.resize(8*4, 0x00);
	msg.nonce_ = {0x12, 0x34, 0x56, 0x78};
	auto backup_msg = msg;

	vector<uint8_t> control_gamma = {0xdc, 0x46, 0xe1, 0x67, 0xab, 0xa4, 0xb3, 0x65, 0xe5, 0x71, 0xca, 0x97, 0x2e, 0xf0, 0xc0, 0x49, 0x59, 0xf5, 0x7d, 0xa6, 0x60, 0x1a, 0xd9, 0xa3, 0xdf, 0x9c, 0xf6, 0x1b, 0xbc, 0xe7, 0xdf, 0x6c};

	cout << to_hex(msg.text_) << endl;
	CTR::encrypt(magma_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(msg.text_, control_gamma);


	CTR::decrypt(magma_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);
}

void test_ctr_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.text_ =
	{
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
			0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
			0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11,
	};

	vector<uint8_t> control_ct =
	{
			0xf1, 0x95, 0xd8, 0xbe, 0xc1, 0x0e, 0xd1, 0xdb, 0xd5, 0x7b, 0x5f, 0xa2, 0x40, 0xbd, 0xa1, 0xb8,
			0x85, 0xee, 0xe7, 0x33, 0xf6, 0xa1, 0x3e, 0x5d, 0xf3, 0x3c, 0xe4, 0xb3, 0x3c, 0x45, 0xde, 0xe4,
			0xa5, 0xea, 0xe8, 0x8b, 0xe6, 0x35, 0x6e, 0xd3, 0xd5, 0xe8, 0x77, 0xf1, 0x35, 0x64, 0xa3, 0xa5,
			0xcb, 0x91, 0xfa, 0xb1, 0xf2, 0x0c, 0xba, 0xb6, 0xd1, 0xc6, 0xd1, 0x58, 0x20, 0xbd, 0xba, 0x73,
	};

	msg.nonce_ = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0};
	auto backup_msg = msg;

	cout << to_hex(msg.text_) << endl;
	CTR::encrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(control_ct, msg.text_);

	CTR::decrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);

}

void test_ofb_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.text_.resize(16*4, 0x00);
	msg.nonce_ = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12};
	auto backup_msg = msg;

	cout << to_hex(msg.text_) << endl;
	OFB::encrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;
	OFB::decrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);
}

void test_cbc_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.text_ =
	{
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
			0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
			0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00
	};
	msg.nonce_ = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12};
	auto backup_msg = msg;

	cout << to_hex(msg.text_) << endl;
	CBC::encrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;
	CBC::decrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);
}

void test_cfb_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.text_ =
	{
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
			0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
			0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a
	};
	msg.nonce_ = {0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf0, 0x01, 0x12};
	auto backup_msg = msg;

	cout << to_hex(msg.text_) << endl;
	CFB::encrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;
	CFB::decrypt(kuzn_ptr, msg, msg);
	cout << to_hex(msg.text_) << endl;

	check(backup_msg.text_, msg.text_);
}

void test_cmac_magma()
{
	BlockCipherPtr magma_ptr = buildTestMagma();
	Message msg;
	msg.text_ = {0x92, 0xde, 0xf0, 0x6b, 0x3c, 0x13, 0x0a, 0x59, 0xdb, 0x54, 0xc7, 0x04, 0xf8, 0x18, 0x9d, 0x20
			, 0x4a, 0x98, 0xfb, 0x2e, 0x67, 0xa8, 0x02, 0x4c, 0x89, 0x12, 0x40, 0x9b, 0x17, 0xb5, 0x7e, 0x41};

	CMAC::compute(magma_ptr, msg);

	vector<uint8_t> control_mac = {0x15, 0x4e, 0x72, 0x10, 0x20, 0x30, 0xc5, 0xbb};
	cout << to_hex(msg.mac_) << endl;

	check(msg.mac_, control_mac);
}

void test_cmac_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.text_ =
	{
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
			0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
			0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11
	};

	CMAC::compute(kuzn_ptr, msg);

	vector<uint8_t> control_mac = {0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3, 0x4d, 0xde, 0xb3, 0x5b, 0x37, 0x74, 0x9c, 0x67};
	cout << to_hex(msg.mac_) << endl;

	check(msg.mac_, control_mac);

	cout << CMAC::verify(kuzn_ptr, msg) << endl;
	msg.text_[0] = 0xFF;
	cout << (CMAC::verify(kuzn_ptr, msg) == false) << endl;
}

void test_mgm_kuznyechik()
{
	BlockCipherPtr kuzn_ptr = buildTestKuznyechik();
	Message msg;
	msg.nonce_ = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88};

	msg.auth_data_ =
	{
			0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
			0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
			0xEA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05
	};

	msg.text_ =
	{
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
			0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a,
			0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,
			0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11,
			0xAA, 0xBB, 0xCC
	};

	vector<uint8_t> control_mac = {0xCF, 0x5D, 0x65, 0x6F, 0x40, 0xC3, 0x4F, 0x5C, 0x46, 0xE8, 0xBB, 0x0E, 0x29, 0xFC, 0xDB, 0x4C};

	MGM::encrypt(kuzn_ptr, msg, msg);

	cout << to_hex(msg.text_) << endl;
	cout << to_hex(msg.mac_) << endl;

	MGM::decrypt(kuzn_ptr, msg, msg);

	cout << to_hex(msg.text_) << endl;

	check(msg.mac_, control_mac);
}

void test_mgm_magma()
{
	BlockCipherPtr magma_ptr = buildTestMagma();
	Message msg;

	msg.nonce_ = {0x12, 0xDE, 0xF0, 0x6B, 0x3C, 0x13, 0x0A, 0x59};

	msg.auth_data_ =
	{
			0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
			0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
			0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEA
	};

	msg.text_ =
	{
			0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,
			0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
			0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00,	0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
			0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
			0xAA, 0xBB, 0xCC
	};

	vector<uint8_t> control_ct =
	{
			0xc7, 0x95, 0x06, 0x6c, 0x5f, 0x9e, 0xa0, 0x3b, 0x85, 0x11, 0x33, 0x42, 0x45, 0x91, 0x85, 0xae,
            0x1f, 0x2e, 0x00, 0xd6, 0xbf, 0x2b, 0x78, 0x5d, 0x94, 0x04, 0x70, 0xb8, 0xbb, 0x9c, 0x8e, 0x7d,
            0x9a, 0x5d, 0xd3, 0x73, 0x1f, 0x7d, 0xdc, 0x70, 0xec, 0x27, 0xcb, 0x0a, 0xce, 0x6f, 0xa5, 0x76,
            0x70, 0xf6, 0x5c, 0x64, 0x6a, 0xbb, 0x75, 0xd5, 0x47, 0xaa, 0x37, 0xc3, 0xbc, 0xb5, 0xc3, 0x4e,
            0x03, 0xbb, 0x9c
	};

	vector<uint8_t> control_mac = {0xA7, 0x92, 0x80, 0x69, 0xAA, 0x10, 0xFD, 0x10};

	MGM::encrypt(magma_ptr, msg, msg);

	cout << to_hex(msg.text_) << endl;
	cout << to_hex(msg.mac_) << endl;
	check(msg.text_, control_ct);
	check(msg.mac_, control_mac);

	MGM::decrypt(magma_ptr, msg, msg);

	cout << to_hex(msg.text_) << endl;

	check(msg.mac_, control_mac);
}

void test_gost89ctr()
{
	GOST89Ptr gost89 = buildTestGOST89();

	Message pt1, ct1;
	pt1.text_ = { 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCC, 0xCC, 0xCC, 0xCC,};

	vector<uint8_t> s1 = {0x2A, 0x80, 0xA7, 0xC3, 0xFF, 0xA8, 0xE3, 0x47};
	pt1.nonce_ = s1;

	GOST89CTR::encrypt(gost89, pt1, ct1);

	vector<uint8_t> control_ct1 = {0x0e, 0x49, 0xf2, 0x74, 0xdd, 0x31, 0x6f, 0x2f, 0xb1, 0x97, 0x50, 0xa7, 0xd5, 0x24, 0x7b, 0xa6};

	check(ct1.text_, control_ct1);

	GOST89CTR::decrypt(gost89, ct1, ct1);

	check(ct1.text_, pt1.text_);

	vector<uint8_t> s2 = {0x73, 0xCF, 0x64, 0xE6, 0x7D, 0x4B, 0x42, 0xE6};
	Message pt2, ct2;
	pt2.nonce_ = s2;
	pt2.text_.resize(256);
	for (size_t i = 0; i < 256; i++)
		pt2.text_[i] = i;
	uint8_t *data = pt2.text_.data();
	for (size_t i = 0; i < 32; i++)
		std::reverse(data + i*8, data + (i+1)*8);

	GOST89CTR::encrypt(gost89, pt2, ct2);
	vector<uint8_t> control_ct2 = {0x70, 0xd5, 0x31, 0x4f, 0x58, 0xfc, 0x7b, 0x5b, 0xed, 0xb7, 0xcd, 0x1d, 0xbf, 0xa9, 0x66, 0xf2, 0x2f, 0xf8, 0x64, 0xa4, 0xd3, 0x60, 0xa4, 0xc0, 0x5c, 0xe6, 0xa0, 0xab, 0x3d, 0xd4, 0x4b, 0x87, 0xb0, 0xdd, 0x00, 0x79, 0xe6, 0x50, 0x0e, 0x70, 0x0e, 0x87, 0x80, 0x36, 0x0f, 0x75, 0x5b, 0xc5, 0x17, 0x81, 0xcc, 0x19, 0x12, 0xb7, 0x87, 0x04, 0x6f, 0xc8, 0x26, 0x6e, 0xf7, 0xc2, 0xd2, 0x78, 0x1f, 0x48, 0xc2, 0x4b, 0x3e, 0x6d, 0xdd, 0x2b, 0x1b, 0x5b, 0xc3, 0x53, 0x0e, 0x0d, 0xff, 0x72, 0x65, 0x55, 0x97, 0xe0, 0x81, 0x2a, 0x44, 0x45, 0x16, 0xf3, 0xb9, 0xa9, 0x7c, 0xb1, 0xde, 0x03, 0x57, 0x5f, 0x5c, 0xd1, 0xad, 0xc0, 0x40, 0x40, 0x35, 0x8a, 0x60, 0xa1, 0xe7, 0x80, 0x58, 0xbe, 0x37, 0xa5, 0x5e, 0xca, 0x15, 0x8c, 0x6a, 0xdd, 0x83, 0xd2, 0x36, 0xad, 0x30, 0x72, 0x7c, 0xe2, 0xc2, 0x5b, 0xcb, 0xfa, 0x26, 0xde, 0x87, 0x23, 0x04, 0x9b, 0x28, 0x2b, 0x13, 0xdb, 0xe6, 0xed, 0xe4, 0xbf, 0xd2, 0x1c, 0xc4, 0x24, 0xee, 0x9f, 0xb7, 0x32, 0xfa, 0xc4, 0x7a, 0x78, 0x7e, 0x64, 0x8f, 0xa6, 0x14, 0xaf, 0x1f, 0x73, 0xf1, 0xda, 0x92, 0x1c, 0x0e, 0x49, 0x97, 0x28, 0x37, 0x80, 0x73, 0x35, 0xf0, 0x73, 0xc1, 0xf6, 0x93, 0x10, 0x87, 0xea, 0x8b, 0x2f, 0xe8, 0x34, 0x25, 0xd4, 0x73, 0xf6, 0xd6, 0x86, 0x35, 0xd8, 0x0c, 0xf5, 0xc6, 0xc3, 0x7b, 0xbe, 0x3a, 0x48, 0x6e, 0xef, 0x4e, 0xe3, 0x17, 0xa7, 0xeb, 0x1a, 0x2c, 0x0b, 0x54, 0xe5, 0x95, 0x11, 0x23, 0x7e, 0x21, 0x99, 0x23, 0xd8, 0xd1, 0x29, 0xd2, 0xc7, 0x13, 0x99, 0x5b, 0x75, 0x67, 0x1f, 0xc2, 0x00, 0x89, 0x34, 0xa7, 0x4d, 0x79, 0xdc, 0x4f, 0x99, 0x74, 0x3e, 0x8e, 0xa4, 0xf2, 0xcc, 0x7d, 0xdf, 0x2e, 0xcb};
	check(ct2.text_, control_ct2);

	CFB::encrypt(gost89, pt1, ct1);
	cout << to_hex(ct1.text_) << endl;
	//3b4c224310bd644b99eb4855d96caa0f

	CFB::encrypt(gost89, pt2, ct2);
	cout << to_hex(ct2.text_) << endl;
	//f9f8fafbfcfdfffe3c627928bfe607ab6a7be340a6c8e37c3fbfcc4ec0cf2c29d457bc3d57ae14763473259dede147c2a286d9c58cc6f54f47a4b606352236ed7114f03de82e466625a739718ce5400b77c31b72dfaba0fbbbc6b316d7d2797c13614fba6e6f7a5326eb2e657730a68697ec4a816cb95af5ffd4bfbb4f3e2430ec4b0eb9def1804bd97708f764d8d190272f6761944be050e128015b7f094f43dfb7705f69b95e7ef39f65fea896f9dcd7f160eff8d58379087bf0b71ba05c1776d37de2fa010d0bb3edf3fef1bda30e8d6801954f3ad87a60cc9719fe39bc80accc48a361b3704b8a43f5ea01d82d0645e9c7fc442f6db408853b0939c8645f

	//pseudo mode!
	//GOST 28147-89 does't contain CBC mode!
	CBC::encrypt(gost89, pt1, ct1);
	cout << to_hex(ct1.text_) << endl;
	//e890870c2a65c4a6144b65c1730e52dd

	CBC::encrypt(gost89, pt2, ct2);
	cout << to_hex(ct2.text_) << endl;
	//184717027e3b62fa7581febea2071725064d7b64db9903807459f749eed0bf4f1a35dafd5f7af1d8e8fc4c01249b2e3a77f5b3b415739811069afba3ef9a6e0302582df3b03030ddc48a4a458f6ac1fe308f948c8dc0dba57a67939db8cf86c722b024b8079fce3fdd4e1e4a43fe3fbaaae0c44d6c93a239f9e6ff35ab985315a656eb5743b3bbda86bf6324931616de9e935dc17663a717c8c6f7c9197e92a151d1106811d9f2fe552aa484250a1437bd3fd8d9f71e816c3f6f6618c35647d19a919560441818d372aa43884f0be0634ef55acb53ae990f6114a25041f941f2db4f48fd648774e13cc9e6c24799fc1f2efc1ce9d146bb09368e1a378743f821
}




#endif /* TEST_H_ */
